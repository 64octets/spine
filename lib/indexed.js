// Generated by CoffeeScript 1.6.2
(function() {
  var $, Base, Collection, DbMetadata, DefaultMigration, Extend, Include, Model, Singleton, Spine, doMigration,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Spine = this.Spine || require('spine');

  $ = Spine.$;

  Model = Spine.Model;

  DefaultMigration = function(db, versionChangeEvent) {
    return db.createObjectStore(this.dbMetadata.objectStoreName, {
      keyPath: this.dbMetadata.primaryKey,
      autoIncrement: this.dbMetadata.autoIncrement
    });
  };

  DbMetadata = function(options) {
    this.name = options.name;
    this.version = options.version;
    this.primaryKey = options.primaryKey;
    this.autoIncrement = options.autoIncrement;
    this.objectStoreName = options.objectStoreName;
    return this.migrations = {
      1: DefaultMigration
    };
  };

  doMigration = function(modelContext, db, versionChangeEvent) {
    var migration;

    migration = modelContext.dbMetadata.migrations[db.version];
    return migration && migration.call(modelContext, db, versionChangeEvent);
  };

  Base = (function() {
    function Base() {}

    Base.prototype.extended = function() {
      return this.dbMetadata = new DbMetadata({
        name: "default",
        version: 1,
        primaryKey: "id",
        autoIncrement: true,
        objectStoreName: this.className
      });
    };

    Base.prototype.connect = function(callback) {
      var dbRequest, that;

      dbRequest = indexedDB.open(this.dbMetadata.name, this.dbMetadata.version);
      that = this;
      dbRequest.onsuccess = function(e) {
        var db, versionRequest;

        db = this.result;
        if (parseFloat(db.version) !== that.dbMetadata.version) {
          versionRequest = db.setVersion(that.dbMetadata.version);
          return versionRequest.onsuccess = function(e) {
            doMigration(that, db, null);
            callback.call(that, db);
            return db.close();
          };
        } else {
          callback.call(that, db);
          return db.close();
        }
      };
      dbRequest.onupgradeneeded = function(evt) {
        return doMigration(that, this.result, evt);
      };
      return dbRequest.onerror = function() {
        return console.log("Error while creating dbRequest");
      };
    };

    return Base;

  })();

  Collection = (function(_super) {
    __extends(Collection, _super);

    function Collection(model) {
      this.model = model;
    }

    Collection.prototype.fetch = function() {
      return this.connect(function(db) {
        var objectStore, that;

        objectStore = db.transaction(this.dbMetadata.objectStoreName).objectStore(this.dbMetadata.objectStoreName);
        that = this;
        if (objectStore.getAll) {
          return objectStore.getAll().onsuccess = function(event) {
            that.refresh(this.result);
            return console.log('Fetched all data');
          };
        } else {
          return objectStore.openCursor().onsuccess = function(event) {
            var cursor;

            cursor = event.target.result;
            if (cursor) {
              that.refresh(cursor.value);
              return cursor["continue"]();
            } else {
              return console.log('Fetched all data');
            }
          };
        }
      });
    };

    return Collection;

  })(Base);

  Singleton = (function(_super) {
    __extends(Singleton, _super);

    function Singleton(record) {
      this.record = record;
      this.model = this.record.constructor;
    }

    Singleton.prototype.create = function(record, options) {
      return this.connect(function(db) {
        var oldId, store, transaction, writeRequest;

        transaction = db.transaction(this.dbMetadata.objectStoreName, IDBTransaction.READ_WRITE);
        transaction.oncomplete = function() {
          return console.log('Transaction complete');
        };
        store = transaction.objectStore(this.dbMetadata.objectStoreName);
        oldId = record.__proto__.id;
        if (this.dbMetadata.autoIncrement) {
          delete record.__proto__.id;
        }
        writeRequest = store.add(record.__proto__);
        writeRequest.onsuccess = function(e) {
          var id, records;

          if (oldId !== e.target.result) {
            id = e.target.result;
            records = record.constructor.records;
            records[id] = records[oldId];
            delete records[oldId];
          }
          return console.log('Data created');
        };
        return writeRequest.onerror = function(e) {
          return console.log("Error while creating");
        };
      });
    };

    Singleton.prototype.destroy = function(record, options) {
      return this.connect(function(db) {
        var request;

        request = db.transaction(this.dbMetadata.objectStoreName, IDBTransaction.READ_WRITE).objectStore(this.dbMetadata.objectStoreName)["delete"](record.id);
        request.onsuccess = function(e) {
          return console.log('Data removed');
        };
        return request.onerror = function() {
          return console.log("Error while removing");
        };
      });
    };

    Singleton.prototype.update = function(record, options) {
      return this.connect(function(db) {
        var store, transaction, writeRequest;

        transaction = db.transaction(this.dbMetadata.objectStoreName, IDBTransaction.READ_WRITE);
        transaction.oncomplete = function() {
          return console.log('Transaction complete');
        };
        store = transaction.objectStore(this.dbMetadata.objectStoreName);
        writeRequest = store.put(record.__proto__);
        writeRequest.onsuccess = function(e) {
          return console.log('Data updated');
        };
        return writeRequest.onerror = function(e) {
          return console.log("Error while updating");
        };
      });
    };

    return Singleton;

  })(Base);

  Include = {
    indexedDb: function() {
      return new Singleton(this);
    }
  };

  Extend = {
    indexedDb: function() {
      return new Collection(this);
    }
  };

  Spine.Model.IndexedDb = {
    extended: function() {
      this.change(this.indexedDbChange);
      this.fetch(this.indexedDbFetch);
      this.extend(Extend);
      return this.include(Include);
    },
    indexedDbFetch: function() {
      return this.indexedDb.fetch();
    },
    indexedDbChange: function(record, type, options) {
      if (options == null) {
        options = {};
      }
      if (options.indexedDb === false) {
        return;
      }
      return record.indexedDb()[type](options);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Spine.Model.IndexedDb;
  }

}).call(this);
