// Generated by CoffeeScript 1.6.2
(function() {
  var $, Base, Collection, DbMetadata, DefaultMigration, Model, Singleton, Spine, doMigration;

  Spine = this.Spine || require('spine');

  $ = Spine.$;

  Model = Spine.Model;

  DefaultMigration = function(db, versionChangeEvent) {
    return db.createObjectStore(this.dbMetadata.objectStoreName, {
      keyPath: this.dbMetadata.primaryKey,
      autoIncrement: this.dbMetadata.autoIncrement
    });
  };

  DbMetadata = function(options) {
    this.name = options.name;
    this.version = options.version;
    this.primaryKey = options.primaryKey;
    this.autoIncrement = options.autoIncrement;
    this.objectStoreName = options.objectStoreName;
    return this.migrations = {
      1: DefaultMigration
    };
  };

  doMigration = function(modelContext, db, versionChangeEvent) {
    var migration;

    migration = modelContext.dbMetadata.migrations[db.version];
    return migration && migration.call(modelContext, db, versionChangeEvent);
  };

  Base = {
    extended: function() {
      return this.dbMetadata = new DbMetadata({
        name: "default",
        version: 1,
        primaryKey: "id",
        autoIncrement: true,
        objectStoreName: this.className
      });
    },
    connect: function(callback) {
      var dbRequest, that;

      dbRequest = indexedDB.open(this.dbMetadata.name, this.dbMetadata.version);
      that = this;
      dbRequest.onsuccess = function(e) {
        var db, versionRequest;

        db = this.result;
        if (parseFloat(db.version) !== that.dbMetadata.version) {
          versionRequest = db.setVersion(that.dbMetadata.version);
          return versionRequest.onsuccess = function(e) {
            doMigration(that, db, null);
            callback.call(that, db);
            return db.close();
          };
        } else {
          callback.call(that, db);
          return db.close();
        }
      };
      dbRequest.onupgradeneeded = function(evt) {
        return doMigration(that, this.result, evt);
      };
      return dbRequest.onerror = function() {
        return console.log("Error while creating dbRequest");
      };
    }
  };

  Collection = {
    fetch: function() {
      return this.connect(function(db) {
        var objectStore, that;

        objectStore = db.transaction(this.dbMetadata.objectStoreName).objectStore(this.dbMetadata.objectStoreName);
        that = this;
        if (objectStore.getAll) {
          return objectStore.getAll().onsuccess = function(event) {
            that.refresh(this.result);
            return console.log('Fetched all data');
          };
        } else {
          return objectStore.openCursor().onsuccess = function(event) {
            var cursor;

            cursor = event.target.result;
            if (cursor) {
              that.refresh(cursor.value);
              return cursor["continue"]();
            } else {
              return console.log('Fetched all data');
            }
          };
        }
      });
    }
  };

  Singleton = {
    create: function(record) {
      return this.connect(function(db) {
        var oldId, store, transaction, writeRequest;

        transaction = db.transaction(this.dbMetadata.objectStoreName, IDBTransaction.READ_WRITE);
        transaction.oncomplete = function() {
          return console.log('Transaction complete');
        };
        store = transaction.objectStore(this.dbMetadata.objectStoreName);
        oldId = record.__proto__.id;
        if (this.dbMetadata.autoIncrement) {
          delete record.__proto__.id;
        }
        writeRequest = store.add(record.__proto__);
        writeRequest.onsuccess = function(e) {
          var id, records;

          if (oldId !== e.target.result) {
            id = e.target.result;
            records = record.constructor.records;
            records[id] = records[oldId];
            delete records[oldId];
          }
          return console.log('Data created');
        };
        return writeRequest.onerror = function(e) {
          return console.log("Error while creating");
        };
      });
    },
    destroy: function(record) {
      return this.connect(function(db) {
        var request;

        request = db.transaction(this.dbMetadata.objectStoreName, IDBTransaction.READ_WRITE).objectStore(this.dbMetadata.objectStoreName)["delete"](record.id);
        request.onsuccess = function(e) {
          return console.log('Data removed');
        };
        return request.onerror = function() {
          return console.log("Error while removing");
        };
      });
    },
    update: function(record) {
      return this.connect(function(db) {
        var store, transaction, writeRequest;

        transaction = db.transaction(this.dbMetadata.objectStoreName, IDBTransaction.READ_WRITE);
        transaction.oncomplete = function() {
          return console.log('Transaction complete');
        };
        store = transaction.objectStore(this.dbMetadata.objectStoreName);
        writeRequest = store.put(record.__proto__);
        writeRequest.onsuccess = function(e) {
          return console.log('Data updated');
        };
        return writeRequest.onerror = function(e) {
          return console.log("Error while updating");
        };
      });
    }
  };

  Spine.Model.IndexedDb = {
    extended: function() {
      this.extend(Base);
      this.change(this.indexedDbChange);
      return this.fetch(Collection.fetch);
    },
    indexedDbChange: function(record, type, options) {
      return Singleton[type].call(this, record);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Spine.Model.IndexedDb;
  }

}).call(this);
